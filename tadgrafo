#!/usr/bin/python
# -*- coding: utf-8 -*-
import random
import math


class Vert:
  def __init__(self,node):
    self.id = node
    self.vecinos = {}
    self.visitado = False

  def add_neighbor (self ,dst,w = 0):
    self.vecinos[dst] = weight

  def get_neighbors (self):
    return self.vecinos

  def get_weight (self, dst):
    return self.vecinos[dst]

  def visitar(self):
    self.visitado = True

  def fue_visitado(self):
    return self.visitado

  def setear_no_visitado(self):
    self.visitado = False


class Digraph:
  """Grafo no dirigido con un número fijo de vértices.

  Los vértices son siempre números enteros no negativos. El primer vértice
  es 0.

  El grafo se crea vacío, se añaden las aristas con add_edge(). Una vez
  creadas, las aristas no se pueden eliminar, pero siempre se puede añadir
  nuevas aristas.
  """
  def __init__(g, V):
    """Construye un grafo sin aristas de V vértices.
    """
    g.cant_vertices = V
    g.cant_aristas = 0
    g.vertices = {}
    for i in range(0,V):
      new_vert = Vert(i)
      g.vertices[i] = new_vert

  def V(g):
    """Número de vértices en el grafo.
    """
    return g.cant_vertices

  def E(g):
    """Número de aristas en el grafo.
    """
    return g.cant_aristas

  def adj_e(g, v):
    """Itera sobre los aristas incidentes _desde_ v.
    """
    aristas_incidentes_de_v = {}
    cant_aristas_incidentes_desde_v = 0
    for i in range(0,cant_aristas):
      if g.aristas[i].get_from() == v : 
        aristas_incidentes_de_v[cant_aristas_incidentes_desde_v] = g.vertices[g.aristas[i].get_to()]
        cant_aristas_incidentes_desde_v = cant_aristas_incidentes_desde_v + 1
    return iter(range(aristas_incidentes_de_v()))



  def adj(g, v):
    """Itera sobre los vértices adyacentes a ‘v’.
    """
    return iter(range(g.vertices[v].get_neighbors(g.vertices[v])))


  def add_edge(g, u, v, weight=0):
    """Añade una arista al grafo.
    """
    g.cant_aristas = g.cant_aristas + 1
    g.vertices[u].add_neighbor(g.vertices[v],weight)
    g.vertices[v].add_neighbor(g.vertices[u],weight)
    new_edge = Arista(u,v,weight)
    g.aristas[g.cant_aristas] = new_edge


  def __iter__(g):
    """Itera de 0 a V."""
    return iter(range(g.vertices()))

  def iter_edges(g):
    """Itera sobre todas las aristas del grafo.

    Las aristas devueltas tienen los siguientes atributos de solo lectura:

        • e.src
        • e.dst
        • e.weight
    """
    return iter(range(g.aristas()))

  def sacar_visitados(g):
    for i in range(0,g.V):
      g.vertices[i].setear_no_visitado()

  def get_weight(g,i,f):
    for i in range(0,cant_aristas):
          if g.aristas[i].get_from() == v : 
            aristas_incidentes_de_v[cant_aristas_incidentes_desde_v] = g.vertices[g.aristas[i].get_to()]
            cant_aristas_incidentes_desde_v = cant_aristas_incidentes_desde_v + 1
    
class Arista:
  """Arista de un grafo.
  """
  def __init__(self, src, dst, weight):
  # inicializar y do things 
    self.src = src
    self.dst = dst
    self.weight = weight
  
  def get_weight (self):
    return self.weight

  def get_from (self):
    return self.src

  def get_to (self):
    return self.dst




def heuristica (g,i,f,peso = 0):
  u = random.random()        # Random float x, 0.0 <= x < 1.0     
  vecinos = i.get_neighbors() 
  if f in i.get_neighbors().keys():
    return (get_weight(g,i,f) + peso)
  else:
    if u < 0.75 :
      menor = get_nodo_menor_peso(g,i,vecinos)
      peso = peso + get_weight(menor)
      return heuristica(g,menor,f,peso)
    else:
      nodo = get_random_nodo(vecinos)
      peso = peso + get_weight(nodo)
      return heuristica(g,nodo,f,peso)

def get_nodo_menor_peso(g,i,vect):
  peso = None 
  for x in vect:
    if peso == None : 
      peso = dar_peso(g,i,x)
    else:
      aux_peso = dar_peso(g,i,x)
      if (peso > aux_peso):
        peso = aux_peso
  return peso

def dar_peso(g,i,f):
  for i in range(0,cant_aristas):
    if g.aristas[i].get_from() == i and g.aristas[i].get_to() == f: 
      return g.aristas[i].get_weight()

def get_random_nodo(vecinos):
  cant_vecinos = len(vecinos)
  num_random = randint(0,cant_vecinos)
  return vecinos[num_random]

# link importante: http://code.activestate.com/recipes/119466-dijkstras-algorithm-for-shortest-paths/

asd = Digraph(4)
